<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>resilience4ts</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="getting-started/index.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-started/core-concepts.html"><strong aria-hidden="true">1.1.</strong> Core Concepts</a></li></ol></li><li class="chapter-item expanded "><a href="core-modules/index.html"><strong aria-hidden="true">2.</strong> Core Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="core-modules/bulkhead.html"><strong aria-hidden="true">2.1.</strong> Bulkhead</a></li><li class="chapter-item expanded "><a href="core-modules/cache.html"><strong aria-hidden="true">2.2.</strong> Cache</a></li><li class="chapter-item expanded "><a href="core-modules/circuit-breaker.html"><strong aria-hidden="true">2.3.</strong> Circuit Breaker</a></li><li class="chapter-item expanded "><a href="core-modules/concurrent-lock.html"><strong aria-hidden="true">2.4.</strong> Concurrent Lock</a></li><li class="chapter-item expanded "><a href="core-modules/concurrent-queue.html"><strong aria-hidden="true">2.5.</strong> Concurrent Queue</a></li><li class="chapter-item expanded "><a href="core-modules/fallback.html"><strong aria-hidden="true">2.6.</strong> Fallback</a></li><li class="chapter-item expanded "><a href="core-modules/hedge.html"><strong aria-hidden="true">2.7.</strong> Hedge</a></li><li class="chapter-item expanded "><a href="core-modules/rate-limiter.html"><strong aria-hidden="true">2.8.</strong> Rate Limiter</a></li><li class="chapter-item expanded "><a href="core-modules/retry.html"><strong aria-hidden="true">2.9.</strong> Retry</a></li><li class="chapter-item expanded "><a href="core-modules/timeout.html"><strong aria-hidden="true">2.10.</strong> Timeout</a></li></ol></li><li class="chapter-item expanded "><a href="frameworks/index.html"><strong aria-hidden="true">3.</strong> Framework Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="frameworks/nestjs/getting-started.html"><strong aria-hidden="true">3.1.</strong> NestJS</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">resilience4ts</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<hr />
<p>Resilience4ts is a distributed-first fault tolerance library for TypeScript inspired by resilience4j, Hystrix, and Polly. Following in the footsteps of its namesake <a href="https://resilience4j.readme.io/docs/getting-started">resilience4j</a>, Resilience4ts also aims to be a transparent fault-tolerance layer via higher-order functions (decorators). Decorators can be stacked to create reusable pipelines of decorators, and can be applied to any asynchronous function or method.</p>
<h2 id="modularization"><a class="header" href="#modularization">Modularization</a></h2>
<p>Resilience4ts decorators are modularized into separate packages, each with its own peer dependencies. This allows you to install only the decorators you need, and to avoid installing unnecessary dependencies.</p>
<h3 id="all-core-modules-and-pipeline-decorators"><a class="header" href="#all-core-modules-and-pipeline-decorators">All Core Modules and Pipeline Decorators</a></h3>
<ul>
<li>@forts/resilience4ts-all</li>
</ul>
<h3 id="core-modules"><a class="header" href="#core-modules">Core Modules</a></h3>
<ul>
<li>@forts/resilience4ts-bulkhead</li>
<li>@forts/resilience4ts-cache</li>
<li>@forts/resilience4ts-circuit-breaker</li>
<li>@forts/resilience4ts-concurrent-lock</li>
<li>@forts/resilience4ts-concurrent-queue</li>
<li>@forts/resilience4ts-fallback</li>
<li>@forts/resilience4ts-hedge</li>
<li>@forts/resilience4ts-rate-limiter</li>
<li>@forts/resilience4ts-retry</li>
<li>@forts/resilience4ts-timeout</li>
</ul>
<h3 id="framework-modules"><a class="header" href="#framework-modules">Framework Modules</a></h3>
<ul>
<li>@forts/resilience4ts-nestjs</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h1>
<hr />
<p>Across all modules under the <code>@forts/resilience4ts</code> namespace, there are a few core concepts that are shared to provide a consistent experience. </p>
<h2 id="core-configuration"><a class="header" href="#core-configuration">Core Configuration</a></h2>
<p>All <code>@forts/resiliencets</code> decorators are backended by the <code>ResilienceProviderService</code> class, which is responsible for providing a unified interface for interacting with the underlying logging and persistence mechanisms. The <code>ResilienceProviderService</code> needs to be initialized prior to using any of the decorators. This can be done by calling the <code>ResilienceProviderService.forRoot</code>, method, which takes in a <code>ResilienceConfig</code> object, or by defining a <code>resilience.toml</code> file in the root of your project.</p>
<h4 id="example-resiliencetoml-file"><a class="header" href="#example-resiliencetoml-file">Example <code>resilience.toml</code> file:</a></h4>
<pre><code class="language-toml">[resilience]
serviceName = &quot;my-service&quot;
collectResourceUsage = true
observationInterval = 3000
maxUtilization = 0.9
maxSafeUtilization = 0.75
maxCpuUtilization = 0.9
maxSafeCpuUtilization = 0.75
delimiter = &quot;::&quot;

[redis]
redisHost = &quot;localhost&quot;
redisPort = 6379
redisPrefix = &quot;local&quot;
maxConnectionAttempts = 100
maxBackoff = 3000
maxIncrBackoff = 500
</code></pre>
<h4 id="example-resilienceconfig-object"><a class="header" href="#example-resilienceconfig-object">Example <code>ResilienceConfig</code> object:</a></h4>
<pre><code class="language-typescript">type ResilienceConfig = {
  resilience: {
    serviceName: string;
    serviceVersion?: string;
    delimiter?: string;
    collectResourceUsage?: boolean;
    observationInterval?: number;
    maxUtilization?: number;
    maxSafeUtilization?: number;
    maxCpuUtilization?: number;
    maxSafeCpuUtilization?: number;
  };
  redis: {
  redisHost: string;
  redisPort: number;
  redisPassword?: string;
  redisUser?: string;
  redisPrefix?: string;
  maxConnectionAttempts?: number;
  maxBackoff?: number;
  maxIncrBackoff?: number;
  rejectUnauthorized?: boolean;
  useTls?: boolean;
};
};
</code></pre>
<h4 id="example-resilienceproviderserviceforroot-call"><a class="header" href="#example-resilienceproviderserviceforroot-call">Example <code>ResilienceProviderService.forRoot</code> call:</a></h4>
<pre><code class="language-typescript">import { ResilienceProviderService } from '@forts/resilience4ts-core';

async function bootstrap() {
  svc = ResilienceProviderService.forRoot({
    resilience: {
      serviceName: 'r4t-test',
    },
    redis: {
      redisHost: 'localhost',
      redisPort: 6379,
      redisPassword: 'pwd',
      redisUser: 'user',
      redisPrefix: 'r4t-test',
    },
  });
  await svc.start();
}

bootstrap();
</code></pre>
<h2 id="predicatebuilder"><a class="header" href="#predicatebuilder">PredicateBuilder</a></h2>
<p>A <code>PredicateBuilder</code> is a function that takes in a <code>Predicate</code> and returns a <code>Predicate</code>. A <code>Predicate</code> is a function that takes in a <code>Context</code> and returns a <code>boolean</code>. In the context of a resilience4ts decorator, the <code>Context</code> is typically the result of the decorated function. <code>PredicateBuilder</code>s are commonly used to create <code>Predicate</code>s that check the result of the decorated function for a certain value, or to check the <code>Context</code> for a certain value. An example of this can be found in the <code>@forts/resilience4ts-fallback</code> module, where the optional <code>shouldHandle</code> property on the <code>Fallback</code> decorator config takes a <code>PredicateBuilder</code> to determine whether or not the fallback action should be executed based on the result of the decorated function.</p>
<pre><code class="language-typescript">import { 
  PredicateBuilder, 
  OperationCancelledException
} from '@forts/resilience4ts-core';
import { Fallback } from '@forts/resilience4ts-fallback';

const fallback = Fallback.of('my-fallback', {
  shouldHandle: new PredicateBuilder()
    .isnot(OperationCancelledException),
  fallbackAction: () =&gt; 'fallback',
});

const result = await fallback.on(async () =&gt; {
  // do something
})();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-modules-1"><a class="header" href="#core-modules-1">Core Modules</a></h1>
<ul>
<li><a href="core-modules/./bulkhead.html">Bulkhead</a></li>
<li><a href="core-modules/./chapter_1.html">Cache</a></li>
<li><a href="core-modules/./chapter_1.html">Circuit Breaker</a></li>
<li><a href="core-modules/./chapter_1.html">Concurrent Lock</a></li>
<li><a href="core-modules/./chapter_1.html">Concurrent Queue</a></li>
<li><a href="core-modules/./chapter_1.html">Fallback</a></li>
<li><a href="core-modules/./chapter_1.html">Hedge</a></li>
<li><a href="core-modules/./chapter_1.html">Rate Limiter</a></li>
<li><a href="core-modules/./chapter_1.html">Retry</a></li>
<li><a href="core-modules/./chapter_1.html">Timeout</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bulkhead"><a class="header" href="#bulkhead">Bulkhead</a></h1>
<hr />
<h3 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h3>
<p>Resilience4ts provides two implementations of the bulkhead pattern: <code>Distributed</code> and <code>Instance</code>. The <code>Distributed</code> bulkhead is a distributed-first implementation of the bulkhead pattern, while the <code>Instance</code> bulkhead is an instance-scoped implementation. The <code>Distributed</code> implementation is backed by Redis, and will work across multiple instances of your application. The <code>Instance</code> implementation is backed by a simple in-memory store, and will only limit the number of concurrent executions within a single instance of your application.''</p>
<p>Defaults to <code>Distributed</code> bulkhead.</p>
<h3 id="create-and-configure-a-bulkhead"><a class="header" href="#create-and-configure-a-bulkhead">Create and Configure a Bulkhead</a></h3>
<pre><code class="language-typescript">import { Bulkhead } from '@forts/resilience4ts-bulkhead';

const bulkhead = Bulkhead.of('my-bulkhead', {
  maxConcurrentCalls: 10,
  maxWait: 1000,
});

const result = await bulkhead.on(async () =&gt; {
  // do something
})();
</code></pre>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Config Property</th><th>Default Value</th><th>Description</th></tr></thead><tbody>
<tr><td>getUniqueId</td><td></td><td>Function that returns a unique id for the call from the decorated function args.</td></tr>
<tr><td>maxConcurrent</td><td>10</td><td>Maximum duration in milliseconds that a call is allowed to wait for a permit to be issued.</td></tr>
<tr><td>executionTimeout</td><td>1000</td><td>Maximum duration in milliseconds that a call is allowed to wait for execution.</td></tr>
<tr><td>maxWait</td><td>1000</td><td>Maximum duration in milliseconds that a call is allowed to wait for execution.</td></tr>
<tr><td>kind</td><td><code>BulkheadStrategy.Distributed</code></td><td>Strategy to use for bulkhead.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="cache"><a class="header" href="#cache">Cache</a></h1>
<hr />
<h3 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h3>
<p>Resilience4ts provides decorators for two caching strategies along with a decorator for busting cached values.</p>
<h3 id="installation"><a class="header" href="#installation">Installation</a></h3>
<p><code>npm i @forts/resilience4ts-cache</code></p>
<h3 id="distributed-cache"><a class="header" href="#distributed-cache">Distributed Cache</a></h3>
<p>The <code>DistributedCache</code> decorator is a distributed-first implementation of the cache pattern. It is backed by Redis, and will work across multiple instances of your application.</p>
<pre><code class="language-typescript">import { Cache } from '@forts/resilience4ts-cache';

const cache = Cache.of('my-cache', {
  extractKey: (...args: Parameters&lt;MyDecoratedMethod&gt;) =&gt; UniqueId, // Function that returns a unique id for the call from the decorated function args.
  ttl: 1000, // Time to live in milliseconds.
  maxCapacity: 100, // Maximum number of entries in the cache.
});

const result = await cache.on(async () =&gt; {
  // do something
})();
</code></pre>
<h3 id="request-scoped-cache"><a class="header" href="#request-scoped-cache">Request-Scoped Cache</a></h3>
<p>The <code>RequestScopedCache</code> decorator is an instance-scoped implementation of the cache pattern. It is backed by a simple in-memory store, and will only cache values within the lifecycle of a single request. Once the configured <code>RequestContext</code> object is garbage-collected, any cached values under that context will be garbage-collected as well.</p>
<pre><code class="language-typescript">import { RequestScopedCache, RequestScopedCacheType } from '@forts/resilience4ts-cache';

const cache = RequestScopedCache.of('my-cache', {
  extractScope: (...args: Parameters&lt;MyDecoratedMethod&gt;) =&gt; Record&lt;string, any&gt;, // Function that returns a &quot;scope&quot; to associate with the cache entry from the decorated function args.
  extractKey: (...args: Parameters&lt;MyDecoratedMethod&gt;) =&gt; UniqueId, // Function that returns a unique id for the call from the decorated function args.
});

const result = await cache.on(async () =&gt; {
  // do something
})();
</code></pre>
<h3 id="cache-buster"><a class="header" href="#cache-buster">Cache Buster</a></h3>
<p>The <code>CacheBuster</code> decorator is used to bust cached values and is used as a companion to the distributed <code>@Cache</code> decorator. It can be used to bust one or more cached values based on the result of the decorated function.</p>
<pre><code class="language-typescript">import { CacheBuster } from '@forts/resilience4ts-cache';

const cacheBuster = CacheBuster.of('my-cache-buster', {
  invalidatesKeys: (...args: Parameters&lt;MyDecoratedMethod&gt;) =&gt; string | string[], // Function that returns a key or list of keys to bust from the cache.
});

const result = await cacheBuster.on(async () =&gt; {
  // do something
})();
</code></pre>
<p>A <code>CacheBuster</code> can optionally take a <code>PredicateBuilder</code> via the <code>shouldInvalidate</code> property to determine whether or not the cache should be busted based on the result of the decorated function.</p>
<pre><code class="language-typescript">import { CacheBuster, PredicateBuilder } from '@forts/resilience4ts-cache';

const cacheBuster = CacheBuster.of('my-cache-buster', {
  invalidatesKeys: (...args: Parameters&lt;MyDecoratedMethod&gt;) =&gt; string | string[], // Function that returns a key or list of keys to bust from the cache.
  shouldInvalidate: new PredicateBuilder().isnot(OperationCancelledException), // Optional. Function that returns a boolean to determine whether or not the cache should be busted based on the result of the decorated function.
});
</code></pre>
<p>By default, the <code>CacheBuster</code> will only bust the cache if the decorated function does not throw an error.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuit-breaker"><a class="header" href="#circuit-breaker">Circuit Breaker</a></h1>
<hr />
<h3 id="introduction-3"><a class="header" href="#introduction-3">Introduction</a></h3>
<p>The CircuitBreaker is implemented via a finite state machine with three normal states: <code>CLOSED</code>, <code>OPEN</code> and <code>HALF_OPEN</code>. The <code>CLOSED</code> state is the normal state of the circuit breaker. In this state, the circuit breaker is allowing executions of the decorated function. If the decorated function fails, the circuit breaker will record the failure. If the number of failures exceeds the configured threshold, the circuit breaker will transition to the <code>OPEN</code> state. In the <code>OPEN</code> state, the circuit breaker will not allow executions of the decorated function. After the configured interval has elapsed, the circuit breaker will transition to the <code>HALF_OPEN</code> state. In the <code>HALF_OPEN</code> state, the circuit breaker will allow a configurable number of executions of the decorated function. If all executions succeed, the circuit breaker will transition back to the <code>CLOSED</code> state. If any executions fail, the circuit breaker will transition back to the <code>OPEN</code> state.</p>
<h3 id="count-based-sliding-window"><a class="header" href="#count-based-sliding-window">Count-based sliding window</a></h3>
<p>The count-based sliding window is implemented with a circular array of N measurements.
If the count window size is 10, the circular array has always 10 measurements.
The sliding window incrementally updates a total aggregation. The total aggregation is updated when a new call outcome is recorded. When the oldest measurement is evicted, the measurement is subtracted from the total aggregation and the bucket is reset. (Subtract-on-Evict)</p>
<h3 id="time-based-sliding-window"><a class="header" href="#time-based-sliding-window">Time-based sliding window</a></h3>
<p>The time-based sliding window is implemented with a circular array of N partial aggregations (buckets).
If the time window size is 10 seconds, the circular array has always 10 partial aggregations (buckets). Every bucket aggregates the outcome of all calls which happen in a certain epoch second. (Partial aggregation). The head bucket of the circular array stores the call outcomes of the current epoch second. The other partial aggregations store the call outcomes of the previous seconds.
The sliding window does not store call outcomes individually, but incrementally updates partial aggregations (bucket) and a total aggregation.
The total aggregation is updated incrementally when a new call outcome is recorded. When the oldest bucket is evicted, the partial total aggregation of that bucket is subtracted from the total aggregation and the bucket is reset. (Subtract-on-Evict)</p>
<h3 id="failure-rate-threshold"><a class="header" href="#failure-rate-threshold">Failure Rate Threshold</a></h3>
<p>The state of the CircuitBreaker changes from <code>CLOSED</code> to <code>OPEN</code> when the failure rate is equal or greater than a configurable threshold. For example when more than 50% of the recorded calls have failed.
By default all exceptions count as a failure. You can define a list of exceptions which should count as a failure. All other exceptions are then counted as a success, unless they are ignored. Exceptions can also be ignored so that they neither count as a failure nor success.</p>
<p>The failure rate can only be calculated, if a minimum number of calls were recorded. For example, if the minimum number of required calls is 10, then at least 10 calls must be recorded, before the failure rate can be calculated. If only 9 calls have been evaluated the CircuitBreaker will not trip open even if all 9 calls have failed.</p>
<h3 id="create-and-configure-a-circuitbreaker"><a class="header" href="#create-and-configure-a-circuitbreaker">Create and Configure a CircuitBreaker</a></h3>
<pre><code class="language-typescript">import { CircuitBreaker, CircuitBreakerStrategy } from '@forts/resilience4ts-circuit-breaker';

const circuitBreaker = CircuitBreaker.of('my-circuit-breaker', {
  strategy: CircuitBreakerStrategy.Percentage,
  threshold: 0.5,
  interval: 1000 * 60 * 15,
  minimumFailures: 3,
  whitelist: [],
  circuitConnectionRetries: 3,
  halfOpenLimit: 3,
});

const result = await circuitBreaker.on(async () =&gt; {
  // do something
})();
</code></pre>
<h3 id="options-1"><a class="header" href="#options-1">Options</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Config Property</th><th>Default Value</th><th>Description</th></tr></thead><tbody>
<tr><td>strategy</td><td><code>CircuitBreakerStrategy.Percentage</code></td><td>Strategy to use for circuit breaker.</td></tr>
<tr><td>threshold</td><td>0.5</td><td>Threshold for circuit breaker. When <code>strategy</code> is <code>Percentage</code>-based, this threshold represents the maximum allowable failure rate as a percent. When <code>strategy</code> is <code>Volume</code>-based, this threshold represents the maximum allowable failures in the configured time window</td></tr>
<tr><td>interval</td><td>1000 * 60 * 15</td><td>Interval in milliseconds that the circuit breaker will transition to the <code>HALF_OPEN</code> state after being in the <code>OPEN</code> state.</td></tr>
<tr><td>minimumFailures</td><td>3</td><td>Minimum number of failures that must be recorded before the circuit breaker can trip open.</td></tr>
<tr><td>whitelist</td><td>[]</td><td>Error[]. If the decorated method throws an error that is in the whitelist, the circuit breaker will not record it as a failure.</td></tr>
<tr><td>circuitConnectionRetries</td><td>3</td><td>Number of times to retry connecting to the circuit breaker store.</td></tr>
<tr><td>halfOpenLimit</td><td>3</td><td>Number of executions allowed in the <code>HALF_OPEN</code> state.</td></tr>
</tbody></table>
</div>
<h4 id="default-circuit-breaker-config"><a class="header" href="#default-circuit-breaker-config">Default Circuit Breaker Config</a></h4>
<pre><code class="language-typescript">const DefaultCircuitBreakerConfig = {
  strategy: CircuitBreakerStrategy.Percentage,
  threshold: 0.5,
  interval: 1000 * 15,
  minimumFailures: 3,
  whitelist: [],
  circuitConnectionRetries: 3,
  halfOpenLimit: 3,
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrent-lock"><a class="header" href="#concurrent-lock">Concurrent Lock</a></h1>
<hr />
<h3 id="introduction-4"><a class="header" href="#introduction-4">Introduction</a></h3>
<p>The <code>ConcurrentLock</code> module provides a distributed lock implementation. At a high level, there are two reasons why you might want a lock in a distributed application: for efficiency or for correctness [2]. To distinguish these cases, you can ask what would happen if the lock failed:</p>
<ul>
<li>Efficiency: Taking a lock saves you from unnecessarily doing the same work twice (e.g. some expensive computation). If the lock fails and two nodes end up doing the same piece of work, the result is a minor increase in cost (you end up paying 5 cents more to AWS than you otherwise would have) or a minor inconvenience (e.g. a user ends up getting the same email notification twice).</li>
<li>Correctness: Taking a lock prevents concurrent processes from stepping on each others’ toes and messing up the state of your system. If the lock fails and two nodes concurrently work on the same piece of data, the result is a corrupted file, data loss, permanent inconsistency, the wrong dose of a drug administered to a patient, or some other serious problem.</li>
</ul>
<h3 id="installation-1"><a class="header" href="#installation-1">Installation</a></h3>
<p><code>npm i @forts/resilience4ts-concurrent-lock</code></p>
<h3 id="create-and-configure-a-lock"><a class="header" href="#create-and-configure-a-lock">Create and Configure a Lock</a></h3>
<pre><code class="language-typescript">import { ConcurrentLock } from '@forts/resilience4ts-concurrent-lock';

const lock = ConcurrentLock.of('my-lock', {
  withKey: (...args: Parameters&lt;MyDecoratedMethod&gt;) =&gt; UniqueId,
});

const result = await lock.on(async () =&gt; {
  // do something
})();
</code></pre>
<h3 id="options-2"><a class="header" href="#options-2">Options</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Config Property</th><th>Default Value</th><th>Description</th></tr></thead><tbody>
<tr><td>withKey</td><td></td><td>Function that returns a unique id for the call from the decorated function args.</td></tr>
<tr><td>duration</td><td></td><td>Duration in milliseconds to wait for the lock to be released.</td></tr>
<tr><td>extensible</td><td></td><td>Whether the lock is extensible.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="concurrent-queue"><a class="header" href="#concurrent-queue">Concurrent Queue</a></h1>
<hr />
<h2 id="introduction-5"><a class="header" href="#introduction-5">Introduction</a></h2>
<p>The <code>ConcurrentQueue</code> decorator wraps a function with a distributed, blocking queue that ensures only one instance of the function is running at a time. If the function is called while another instance is running, the function will be queued and executed when the previous instance completes.</p>
<p>Because the queue is blocking, the caller will wait until the function completes before continuing. If the caller fails to acquire the lock, a <code>QueueWaitExceeded</code> exception will be thrown. The use-cases for this are limited, but it can be useful in some situations so please consider your application's needs before using this module.</p>
<h2 id="installation-2"><a class="header" href="#installation-2">Installation</a></h2>
<p><code>npm i @forts/resilience4ts-concurrent-queue</code></p>
<h2 id="create-and-configure-a-queue"><a class="header" href="#create-and-configure-a-queue">Create and Configure a Queue</a></h2>
<pre><code class="language-typescript">import { ConcurrentQueue } from '@forts/resilience4ts-concurrent-queue';

const queue = ConcurrentQueue.of('my-queue', {
  withKey: (...args: Parameters&lt;MyDecoratedMethod&gt;) =&gt; UniqueId,
});

const result = await queue.on(async () =&gt; {
  // do something
})();
</code></pre>
<h2 id="options-3"><a class="header" href="#options-3">Options</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Config Property</th><th>Default Value</th><th>Description</th></tr></thead><tbody>
<tr><td>withKey</td><td></td><td>Function that returns a unique id for the call from the decorated function args.</td></tr>
<tr><td>maxAttempts</td><td>10</td><td>Maximum number of attempts to acquire the lock and execute the function.</td></tr>
<tr><td>backoff</td><td>0.01</td><td>Backoff factor to use when retrying to acquire the lock.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="fallback"><a class="header" href="#fallback">Fallback</a></h1>
<hr />
<h3 id="introduction-6"><a class="header" href="#introduction-6">Introduction</a></h3>
<p>The fallback strategy provides an interface to define a callback that will be executed if the decorated function fails. This strategy is useful when you want to provide a default value or behavior in the event of a failure. For example, you may want to return a cached value or a default value from a configuration file. The fallback strategy is also useful for providing a graceful degradation of functionality when a service is unavailable, although you should consider using the circuit breaker strategy for this purpose as it provides more control over the failure state.</p>
<h3 id="installation-3"><a class="header" href="#installation-3">Installation</a></h3>
<p><code>npm i @forts/resilience4ts-fallback</code></p>
<h3 id="create-and-configure-a-fallback"><a class="header" href="#create-and-configure-a-fallback">Create and Configure a Fallback</a></h3>
<pre><code class="language-typescript">import { Fallback } from '@forts/resilience4ts-fallback';

const fallback = Fallback.of('my-fallback', {
  fallbackAction: async () =&gt; {
    return &quot;my fallback value&quot;;
  },
});

const result = await fallback.on(async () =&gt; {
  // do something
})();
</code></pre>
<h3 id="options-4"><a class="header" href="#options-4">Options</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Config Property</th><th>Default Value</th><th>Description</th></tr></thead><tbody>
<tr><td>fallbackAction</td><td></td><td>Function that returns a fallback value or executes a fallback action.</td></tr>
<tr><td>shouldHandle</td><td></td><td><code>PredicateBuilder</code> that evaluates to a boolean indicating whether the fallback should be executed.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="hedge"><a class="header" href="#hedge">Hedge</a></h1>
<hr />
<h3 id="introduction-7"><a class="header" href="#introduction-7">Introduction</a></h3>
<p>The hedging strategy enables the re-execution of a user-defined callback if the previous execution takes too long. This approach gives you the option to either run the original callback again or specify a new callback for subsequent hedged attempts. Implementing a hedging strategy can boost the overall responsiveness of the system. However, it's essential to note that this improvement comes at the cost of increased resource utilization. If low latency is not a critical requirement, you may find the retry strategy is more appropriate.</p>
<h3 id="installation-4"><a class="header" href="#installation-4">Installation</a></h3>
<p><code>npm i @forts/resilience4ts-hedge</code></p>
<h3 id="create-and-configure-a-hedge"><a class="header" href="#create-and-configure-a-hedge">Create and Configure a Hedge</a></h3>
<pre><code class="language-typescript">import { Hedge } from '@forts/resilience4ts-hedge';

const hedge = Hedge.of('my-hedge', {
  maxAttempts: 3,
  delay: 1000,
});

const result = await hedge.on(async () =&gt; {
  // do something
})();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rate-limiter"><a class="header" href="#rate-limiter">Rate Limiter</a></h1>
<hr />
<h3 id="introduction-8"><a class="header" href="#introduction-8">Introduction</a></h3>
<p>Rate limiting is an imperative technique to prepare your API for scale and establish high availability and reliability of your service. But also, this technique comes with a whole bunch of different options of how to handle a detected limits surplus, or what type of requests you want to limit. You can simply decline this over limit request, or build a queue to execute them later or combine these two approaches in some way.</p>
<p>The <code>@forts/resilience4ts-rate-limiter</code> module provides strategies for <code>Distributed</code> and <code>Instance</code>-scoped rate limiting. The <code>Distributed</code> implementation is backed by Redis, and will work across multiple instances of your application. The <code>Instance</code> implementation will only limit the number of concurrent executions within a single instance of your application.</p>
<h3 id="installation-5"><a class="header" href="#installation-5">Installation</a></h3>
<p><code>npm i @forts/resilience4ts-rate-limiter</code></p>
<h3 id="create-and-configure-a-rate-limiter"><a class="header" href="#create-and-configure-a-rate-limiter">Create and Configure a Rate Limiter</a></h3>
<pre><code class="language-typescript">import { RateLimiter } from '@forts/resilience4ts-rate-limiter';

const rateLimiter = RateLimiter.of('my-rate-limiter', {
  permitLimit: 10,
  queueLimit: 1000,
  window: 1000,
});

const result = await rateLimiter.on(async () =&gt; {
  // do something
})();
</code></pre>
<h3 id="options-5"><a class="header" href="#options-5">Options</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Config Property</th><th>Default Value</th><th>Description</th></tr></thead><tbody>
<tr><td>requestIdentifier</td><td></td><td>Function that returns a unique id for the call from the decorated function args.</td></tr>
<tr><td>permitLimit</td><td>10</td><td>Maximum number of permits to issue per window.</td></tr>
<tr><td>queueLimit</td><td>1000</td><td>Maximum number of requests to queue.</td></tr>
<tr><td>window</td><td>1000</td><td>Duration in milliseconds that a call is allowed to wait for a permit to be issued.</td></tr>
<tr><td>scope</td><td><code>RateLimiterStrategy.Distributed</code></td><td>Strategy to use for rate limiting.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="retry"><a class="header" href="#retry">Retry</a></h1>
<h3 id="introduction-9"><a class="header" href="#introduction-9">Introduction</a></h3>
<p>The retry strategy enables the re-execution of a user-defined callback if the previous execution fails. This approach gives you the option to either run the original callback again or specify a new callback for subsequent attempts. Implementing a retry strategy can boost the overall reliability of the system. However, it's essential to note that this improvement comes at the cost of increased resource utilization. If high availability is not a critical requirement, you may find the hedging strategy is more appropriate.</p>
<h3 id="installation-6"><a class="header" href="#installation-6">Installation</a></h3>
<p><code>npm i @forts/resilience4ts-retry</code></p>
<h3 id="create-and-configure-a-retry"><a class="header" href="#create-and-configure-a-retry">Create and Configure a Retry</a></h3>
<pre><code class="language-typescript">import { Retry } from '@forts/resilience4ts-retry';

const retry = Retry.of('my-retry', {
  maxAttempts: 3,
  backoff: 1000,
});

const result = await retry.on(async () =&gt; {
  // do something
});
</code></pre>
<h3 id="options-6"><a class="header" href="#options-6">Options</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Config Property</th><th>Default Value</th><th>Description</th></tr></thead><tbody>
<tr><td>wait</td><td>500</td><td>Wait in milliseconds before retrying.</td></tr>
<tr><td>maxAttempts</td><td>3</td><td>Maximum number of attempts to retry.</td></tr>
<tr><td>maxInterval</td><td>60000</td><td>Maximum wait in milliseconds between retries.</td></tr>
<tr><td>retryMode</td><td><code>RetryMode.Linear</code></td><td>Strategy to use for calculating backoff.</td></tr>
<tr><td>validateResult</td><td></td><td>Function returning a boolean indicating whether the result should be retried.</td></tr>
<tr><td>whitelistErrors</td><td></td><td>Array of errors that should be ignored, skipping retry.</td></tr>
<tr><td>onRuntimeError</td><td></td><td>Callback function to execute when an error occurs.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="timeout"><a class="header" href="#timeout">Timeout</a></h1>
<p>The timeout module provides a way to limit the amount of time a function may take to execute. If the function does not complete within the specified time, the module will throw an error.</p>
<h3 id="installation-7"><a class="header" href="#installation-7">Installation</a></h3>
<p><code>npm i @forts/resilience4ts-timeout</code></p>
<h3 id="create-and-configure-a-timeout"><a class="header" href="#create-and-configure-a-timeout">Create and Configure a Timeout</a></h3>
<pre><code class="language-typescript">import { Timeout } from '@forts/resilience4ts-timeout';

const timeout = Timeout.of('my-timeout', {
  timeout: 1000,
});

const result = await timeout.on(async () =&gt; {
  // do something
})();
</code></pre>
<h3 id="options-7"><a class="header" href="#options-7">Options</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Config Property</th><th>Default Value</th><th>Description</th></tr></thead><tbody>
<tr><td>timeout</td><td></td><td>Timeout in milliseconds.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="frameworks"><a class="header" href="#frameworks">Frameworks</a></h1>
<ul>
<li><a href="frameworks/./nestjs/getting-started.html">NestJS</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fortsresilience4ts-nestjs"><a class="header" href="#fortsresilience4ts-nestjs">@forts/resilience4ts-nestjs</a></h1>
<p>Getting started with resilience4ts + NestJS</p>
<h3 id="introduction-10"><a class="header" href="#introduction-10">Introduction</a></h3>
<p>While resilience4ts works well as a standalone library, it also provides a set of decorators for NestJS. These decorators can be used to decorate any NestJS controller or service method. <code>@forts/resilience4ts-nestjs</code> wraps all the core resilience4ts decorators plus the <code>@forts/resilience4ts-all</code> decorator into a single package, and re-exports all of them along with convenient method decorators for use with NestJS controllers and services.</p>
<h3 id="installation-8"><a class="header" href="#installation-8">Installation</a></h3>
<p><code>npm i @forts/resilience4ts-nestjs</code></p>
<h3 id="adding-decorators-to-a-nestjs-injectable-service"><a class="header" href="#adding-decorators-to-a-nestjs-injectable-service">Adding Decorators to a NestJS Injectable Service</a></h3>
<p>Taken from the <a href="https://github.com/JHegarty14/resilience4ts/blob/main/examples/nestjs/src/app.service.ts">NestJS example</a></p>
<pre><code class="language-typescript">import {
  Bulkhead,
  CircuitBreaker,
  Fallback,
  CircuitBreakerImpl,
  CircuitBreakerStrategy,
} from '@forts/resilience4ts-nestjs';
import { Inject, Injectable, UnauthorizedException } from '@nestjs/common';
import { AppGateway } from './app.gateway';

type HelloWorldArgs = {
  id: string;
};

@Injectable()
export class AppService {
  constructor(
    @Inject('AppGateway')
    private readonly appGateway: AppGateway,
  ) {}

  // decorators can be stacked, and will be applied in the order they are listed
  @Bulkhead({
    getUniqueId: (args: HelloWorldArgs) =&gt; args.id,
    maxConcurrent: 1,
    maxWait: 250,
  })
  @Fallback({
    shouldHandle: new PredicateBuilder(UnauthorizedException).or(
      (e: Error) =&gt; e.message === 'asdf',
    ),
    fallbackAction: async () =&gt; 'fallback',
  })
  @CircuitBreaker({
    strategy: CircuitBreakerStrategy.Percentage,
    threshold: 0.2,
  })
  async getHello(args: Record&lt;'id', string&gt;) {
    // The original, functional decorators are also available
    // To use them import them as their name + Impl
    // e.g. CircuitBreakerImpl, CacheImpl, etc.
    return await CircuitBreakerImpl.of('gateway.call', {
      strategy: CircuitBreakerStrategy.Percentage,
      threshold: 0.2,
    }).on(this.appGateway.getHello)(args);
  }
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
